module Tools where

import qualified Control.Monad as CM
import Control.Monad.Except hiding (unless)
import qualified Data.Map.Lazy as LMap
--import qualified Data.Map.Strict as SMap LMap.Map == SMap.Map, preventing typeclass fun

type Lookup k a = k -> Maybe a

-- helper function for making strings nicely
(%) :: String -> String -> String
(%) ('{':'}':s) x = x++s
(%) ('\\':c:s) xs = c:(s%xs)
(%) (c:s) xs = c:(s%xs)
(%) "" _ = error "not enough '{}' in string"

infix 0 `unless`
unless :: MonadError e m => e -> Bool -> m ()
unless= flip CM.unless . throwError

withError :: MonadError e m => (e->e) -> m a -> m a
withError f xm = catchError xm (throwError.f)

-- Prepend some context to an error message
infixl 1 ?+
(?+):: Monoid e => MonadError e m => m a -> e -> m a
(?+) = flip $ withError.mappend

assert :: MonadError e m => Bool -> e -> m ()
assert = flip unless

infixl 1 ??
(??) :: MonadError e m => Bool -> e -> m ()
(??) = assert

-- Turn a maybe into an error message
-- Note similarity to ?? - Bool is isomorphic to Maybe ()
-- (??) = CM.guard . (?)
(?) :: MonadError e m => Maybe a -> e -> m a
(?) a b =
    case a of
    Nothing -> throwError b
    Just c -> return c
-- Generated by Djinn (and modified)

fromBoth :: Either a a -> a
fromBoth a =
           case a of
           Left b -> b
           Right c -> c
-- Generated by Djinn

--no, I won't actually use this (I could, but I'm not that evil)
(>=*.$) ::(Functor f, Monad m) => f (m a) -> (a -> m b) -> f (m b)
(>=*.$) = flip (fmap.(=<<))
--(\x a -> x >>= (return . (=<<) a))

lookIn :: Eq a => [(a,b)] -> a -> Maybe b
lookIn = flip lookup

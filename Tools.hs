module Tools where

import qualified Control.Monad as CM
import Control.Monad.Except hiding (unless)
import qualified Data.Map as Map

-- helper function for making strings nicely
(%) :: String -> String -> String
(%) ('{':'}':s) x = x++s
(%) ('\\':c:s) xs = c:(s%xs)
(%) (c:s) xs = c:(s%xs)
(%) "" _ = error "not enough '{}' in string"

infix 0 `unless`
unless :: MonadError e m => e -> Bool -> m ()
unless= flip CM.unless . throwError

withError :: MonadError e m => (e->e) -> m a -> m a
withError f xm = catchError xm (throwError.f)

-- Prepend some context to an error message
(?+):: Monoid e => MonadError e m => m a -> e -> m a
(?+) = flip $ withError.mappend

infixl 1 ?+

assert :: MonadError e m => Bool -> e -> m ()
assert = flip unless

(??) :: MonadError e m => Bool -> e -> m ()
(??) = assert

infixl 1 ??

-- Turn a maybe into an error message
(?) :: Maybe a -> b -> Either b a
(?) a b =
    case a of
    Nothing -> Left b
    Just c -> Right c
-- Generated by Djinn

fromBoth :: Either a a -> a
fromBoth a =
           case a of
           Left b -> b
           Right c -> c
-- Generated by Djinn
